import ldap
import base64
import re
import os

from urllib.parse import urlparse
from colorama import Fore, Style

# Below Data Would Transform To http://10.0.0.16:8180/ExecTemplateJDK5.class
# objectClass: javaNamingReference
# javaCodeBase: http://10.0.0.16:8180/
# javaFactory: ExecTemplateJDK5

# Customization Options
uri_base_colors: str = f"{Fore.LIGHTGREEN_EX}%s{Fore.LIGHTRED_EX}%s"
header_color: str = f"{Fore.LIGHTBLACK_EX}"
info_color: str = f"{Fore.LIGHTYELLOW_EX}"
error_color: str = f"{Fore.RED}%s: "
generic_error_value_color: str = f"{Fore.LIGHTYELLOW_EX}"
key_value_color: str = f"{Fore.GREEN}%s{Fore.LIGHTBLACK_EX}: {Fore.RED}%s"

# Functional Options
log_dir: str = "logs"  # Directory Where Logs Are Stored
ldap_timeout: int = 1  # Seconds

def print_results(uri: str, base: str, results):
    for entry_base, entry in results:
        print(f"{header_color}-"*40)
        print(f"{uri_base_colors}" % (uri, base))
        print(f"{header_color}-"*40)
        for key in entry:
            print(f"{key_value_color}" % (key, entry[key][0].decode("ascii").strip()))
        print(f"{header_color}-{Style.RESET_ALL}"*40)


def grab_urls(results) -> list:
    url_list: list = []
    for entry_base, entry in results:
        javaCodeBase = None
        javaFactory = None
        
        # If Not Known URL Data Type, Skip
        if "objectClass" in entry and entry["objectClass"][0].decode("ascii").strip() != "javaNamingReference":
            continue
        
        # Domain For Malicious Code
        if "javaCodeBase" in entry:
            javaCodeBase = entry["javaCodeBase"][0].decode("ascii").strip()
        
        # Path For Malicious Code
        if "javaFactory" in entry:
            javaFactory = entry["javaFactory"][0].decode("ascii").strip()
        
        if javaCodeBase is not None and javaFactory is not None:
            url_list.append("%s%s.class" % (javaCodeBase, javaFactory))
            
    return url_list

def download_urls(ldap_uri, urls):
    uri_base_encoded: str = base64.urlsafe_b64encode(bytes(ldap_uri, "ascii")).decode("ascii")
    
    print(f"{header_color}-"*40)
    print("Downloading Payloads From (Not Implemented Yet): %s" % (ldap_uri))
    print(f"{header_color}-"*40)
    for url in urls:
        # TODO: Make Dir From uri and base after base64 encoding
        url_encoded: str = "%s.malware" % base64.urlsafe_b64encode(bytes(url, "ascii")).decode("ascii")
        print("Saving %s to %s/%s" % (url, uri_base_encoded, url_encoded))
    print(f"{header_color}-"*40)

def strip_obfuscation(string: str):
    # TODO: Make Case-Insensitive
    return string.replace("${lower:", "").replace("${upper:", "").replace("${", "").replace("}", "").replace("::-", "")

def read_logs():
    # TODO: Extract Logs From GZipped Files
    # TODO: Consider Turning Into Python Generator
    jndi_regex: str = '(jndi[^ "]*)'

    log_files = next(os.walk(log_dir), (None, None, []))[2]
    #print(log_files)
    
    malicious_ldap_urls: list = []
    for log_file in log_files:
        with open(os.path.join(log_dir, log_file)) as log:
            lines = log.read().splitlines()
            for line in lines:
                line = strip_obfuscation(string=line)
                matches = re.findall(jndi_regex, line)
                if len(matches) > 0:
                    #print("Line: %s" % line)
                    #print("Matches: %s" % matches)
                    malicious_ldap_urls.extend(matches)
    
    cleaned_urls: list = []
    for url in malicious_ldap_urls:
        # Filter Out Non-LDAP URLs
        if "ldap://" not in url:
            continue
        
        cleaned_urls.append(url.lstrip("jndi:"))
    
    return cleaned_urls

def attempt_download_payloads(uri: str, base: str):
    # Equivalent Command For URL: ldap://127.0.0.1:1389/togbnj
    # ldapsearch -h 127.0.0.1:1389 -x -b togbnj
    
    try:
        # Connect To Server
        conn = ldap.initialize(uri)
        conn.set_option(ldap.OPT_NETWORK_TIMEOUT, ldap_timeout)
        conn.set_option(ldap.OPT_TIMEOUT, ldap_timeout)
        
        conn.simple_bind_s()
    except ldap.SERVER_DOWN:
        print(f"{error_color}{uri_base_colors}{Style.RESET_ALL}" % ("Server Down: Couldn't Connect To", uri, base))
        return
    except:
        print(f"{error_color}{uri_base_colors}{Style.RESET_ALL}" % ("Exception: Couldn't Connect To", uri, base))
        return

    # Search For Malicious Payload
    try:
        results = conn.search_s(base=base, scope=ldap.SCOPE_SUBTREE)
    except ldap.NO_SUCH_OBJECT:
        print(f"{error_color}{generic_error_value_color}%s{Style.RESET_ALL}" % ("No Such Object", base))
        return
    except:
        print(f"{error_color}{generic_error_value_color}%s{Style.RESET_ALL}" % ("Exception Looking Up Object", base))
        return

    # TODO: Make Sure Results Are Sanitized
    # Print Results
    print_results(uri=uri, base=base, results=results)
    return
    
    # TODO: Make Sure Results Are Sanitized
    # Grab URLs
    urls = grab_urls(results=results)
    
    # Download Payloads
    download_urls(ldap_uri=("%s%s" % (uri, base)), urls=urls)

if __name__ == "__main__":
    malicious_ldap_urls = read_logs()
    for url in malicious_ldap_urls:        
        parsed_url = urlparse(url)
        uri: str = ("%s://%s" % (parsed_url.scheme, parsed_url.netloc)).rstrip("/") + "/"
        base: str = "%s" % parsed_url.path.lstrip("/")  # There's also params, query, and fragment
        print(f"{info_color}Attempting To Download Payloads From: {uri_base_colors}{Style.RESET_ALL}" % (uri, base))
        
        #print("%s - %s" % (uri, base))
        attempt_download_payloads(uri=uri, base=base)
    
